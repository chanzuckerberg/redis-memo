### Cache compatibility
During deployments, the current version of the code and the previous version of the code could both serve requests at the same time. When accessing cache results using a raw cache key directly during deployments, for example:
```ruby
redis.get('cached_result:user:1')
```
One would run into issues if the content in the “cached_result” can only be handled properly by one of the code versions. 

### Cache Invalidation
One could add the latest commit hash to the cache key as follow:
```ruby
redis.get('global_version:fa13db0:cached_result:user:1')
```
So the new code and old code would use separate sets of cache keys and avoid interfering with each other.

Though there’s still an issue:
- If we need to invalidate some cached results, we’d have to delete the cache keys for both global versions, in both new and old codes. Deleting the cache generated by the new code in the new code alone is not sufficient, since update requests might be sent to the old code so the cache generated by the new code also needs to invalidate.

### Memoizable
With RedisMemo, one can still add the commit hash to the cache keys by configuring `global_cache_key_version` (learn more in configurations) to ensure cache compatibility.

The aforementioned invalidation issue does not exist in RedisMemo:
- Memoizables are not prefixed by the `global_cache_key_version` so they are shared by both code versions (learn more about memoizables). Both the new code and the old code are bumping versions on the same memoizables that are used to [reference](https://github.com/chanzuckerberg/redis-memo/wiki/Version-Addressable) the actual globally versioned cached results.
